Инвариант цикла — в программировании — логическое выражение (обычно — равенство), истинное после каждого прохода тела цикла
(после выполнения фиксированного оператора) и перед началом выполнения цикла, зависящее от переменных, изменяющихся в теле цикла.

Инвариант строится таким образом, чтобы быть истинным непосредственно перед началом выполнения цикла (перед входом в первую итерацию)
и после каждой его итерации. 

**Условия, которые остаются неизменными в ходе выполнения алгоритма.
Такие условия называются инвариантами. Умение распознавать инварианты поможет понять суть алгоритма.**
Инварианты также могут пригодиться в ходе отладки; вы можете периодически проверять истинность инвариантов
и выдавать сообщение об ошибке в случае их нарушения.

В программе bubbleSort инвариант определяет, что элементы данных справа от out отсортированы.
Это условие остается истинным. (При первом проходе от- сортированные элементы отсутствуют,
а справа от out нет ни одного элемента, так как счетчик инициализируется позицией крайнего правого элемента.)

Инвариантом является то, что после каждого прохода цикла на вершине массива элементы будут отсортированы.
Поэтому мы используем внешний цикл, каждый раз уменьшая количество сравнений на 1.
  
До начала алгоритма элементы расположены произвольно. На каждом шаге внешнего цикла на свое место «всплывает» один элемент массива.
Поэтому инвариант этого цикла можно сформулировать так:
После выполнения i-го шага цикла последние (i + 1) элементов массива отсортированы и установлены на свои места.

**Доказательство**

Инициализация

Доказывается, что выражение инварианта истинно перед началом цикла.

i = 0

Инвариант: a[i] > a[i - k] для любого k > 0
 
**Доказательство:**

a[0] - первый элемент, a[k] - нет
Доказывается, что выражение инварианта сохраняет свою истинность после выполнения тела цикла; таким образом, по индукции, 
доказывается, что по завершении всего цикла инвариант будет выполняться.

Инвариант: a[i] > a[i - k] для любого k > 0

после i++: i = 1

a[1] > a[0] т.к. по условию если (a[0] > a[1]), то swap(a[0], a[1]), т.е. наибольшим будет a[1].

На i = j итерации: a[i] > a[i - 1] по аналогии и т.к. на предыдущей итерации достигнуто a[i - 1] > a[i - 2], 
а a[i - 1] и a[i] меняются значениями так, что бы a[i] был наибольшим, то a[i] > a[i - 2], аналогично для всех a[i - k]

Таким образом по индукции доказано a[i] < a[i - k] при k > 0

Завершение:

Т.к. a[i] > a[i - k] для любого k > 0 и i > 0 i < N (N – размер массива), то массив отсортирован

**Если за прохождение всего массива не найдется пары, у которой число, имеющее больший индекс, меньше второго числа, то этот массив отсортирован
